The idea here is to make the grammar moduler.
each grammar object has a number of functions associated with it to read,write and modify.
programing a new langage consists of defining the language and then creating objects for
each element of the grammar.

Running a process on a grammar consists of loading the approprate objects and walking the tree.
Walking a tree needs some working parts:
two trees: input, output
with nodes that have the following definitions: type, data, next as well as other node specific types
each tree has the following pointers: head, current, newcurrent

input:    level 1         convert the following things to a node tree.
readfile -> chars
string -> chars
cmdline -> chars
special chars: eof, eol, nul
node->json
node->xml

tokenizer: level 2
chars -> tokens
json -> tokens
xml -> tokens
human -> tokens

parser: level 3 
tokens -> ast
tokens -> json
tokens -> xml
tokens -> human

level 4
walkers: do not modify ast but like transform
warn on nesting level > 5
warn on args > 8
warn on no return value

level 5:
transforms: ast -> ast2
pretty printer
remove trailing whitespace
spaces -> tabs for nesting
desugarize (remove whitespace, comments, docs)
optimazaions
num (+,-,/,*) num  => newnum

output: level 6
ast-> language file
ast-> xml
ast-> json
ast-> human

Need way to select input, output types and filenames?

level 1: array of chars
level 2: array of tokens
level 3: walk tokens to output ast or files.
level 4: walk ast and warn on issues or fix?
level 5: walk ast and produce new ast. combine level 4 and 5?
level 6: walk ast to output files
