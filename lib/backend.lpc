inherit "/std/object";
inherit option "/std/options";

#include "my_bnf.h"

string ofile;		/* name of the current file we are using for output */
int infile;		/* filehandle for current input */

mapping symtable;	/* hash that is used for our symbol table */
mapping symcount;	/* hash used to keep track of how many times our symbls
			are referenced */
object *filesinfo;	/* stack to handle multiple files */
string statsfile;	/* location where we store stats about our parsing */

int bufsize;		/* Number of chars we buffer for match */
int doneread;		/* flag done reading (this is needed because we
				are using a buffer) */

object *tokens;		/* used to store our token stream */
string last_tok_type;	/* used internally to look back one char */
string last_tok_value;	/* used internally to look back one char */

/* these functions are used to report errors and or warnings */
int error(string msg) {
	if (!filename || filename == "") {
		write("Error " + msg + "\n");
	} else {
		write("Error " + filename + ":l:" + stats["linenum"] + ":c:" +
			stats["columnnum"] + ":: " + msg + "\n");
	}
	return 1;
}

int warning(string msg) {
	if (!filename || filename == "") {
		write("WARNING " + msg + "\n");
	} else {
		write("WARNING " + filename + ":l:" + stats["linenum"] + ":c:" +
			stats["columnnum"] + ":: " + msg + "\n");
	}
	return 1;
}

int debug(string msg) {
	string s;
	int x;

	if (option::query_option("debug")) {
		s = "";
		x = 0;
		while (x < SPACES) {
			x = x + 1;
			s = s + "  ";
		}
		write("DEBUG: " + s + msg + "\n");
		return 1;
	}
	return 0;
}

int set_debug (int debug) {
	set_option("debug", debug);

	return debug;
}

string set_eof(string input) {
	EOF = input;

	push_scope();
	debug("set_eof: EOF = " + EOF);
	pop_scope();

	return EOF;
}

string get_eof() {
	return EOF;
}

/* these two functions are used to generate code. */
int emit(string str) {
	int tabc;

	tabc = 0;
	while(tabc < stats["tab"]) {
		write_file(ofile, "\t");
		tabc = tabc + 1;
	}
	write_file(ofile, str);

	return 1;
}

int emitln(string msg) {
	return emit(msg + "\n");
}

void push_scope() {
	SPACES += 1;
}

void pop_scope() {
	SPACES -= 1;
}

/* Misc functions */
int in_set(string in, string *setlist) {
	int x, y;

	x = sizeof(setlist);
	y = 0;
	while (y < x) {
		if (setlist[y] == in) {
			return 1;
		}
		y = y + 1;
	}
	return 0;
}

void pushfileinfo() {
	mapping fileinfo;
	string *keys;
	int i, x;

	push_scope();
	debug("pushfileinfo:");

	fileinfo["infile"] = infile;
	fileinfo["linenum"] = stats["linenum"];
	fileinfo["columnnum"] = stats["columnnum"];
	fileinfo["tab"] = stats["tab"];
	fileinfo["maxtab"] = stats["maxtab"];
	fileinfo["casetype"] = stats["casetype"];

	filesinfo += ({fileinfo});

	if (option::query_option("debug")) {
		debug("Pushing fileinfo:");

		keys = map_indices(fileinfo);
		x = sizeof(keys);
		i = 0;
		while (i < x) {
			debug("\t" + i + " = " + fileinfo[keys[i]]);
			i = i + 1;
		}
	}
	pop_scope();
}

void popfileinfo() {
	string *keys;
	int i, x, z;

	push_scope();
	debug("popfileinfo:");

	z = sizeof(filesinfo);

	infile = filesinfo[z]["infile"];
	stats["linenum"] = filesinfo[z]["linenum"];
	stats["columnnum"] = filesinfo[z]["columnnum"];
	stats["tab"] = filesinfo[z]["tab"];
	stats["maxtab"] = filesinfo[z]["maxtab"];
	stats["casetype"] = filesinfo[z]["casetype"];

	if (option::query_option("debug")) {
		write("Poping fileinfo:\n");
		write("\tinfile = " + infile + "\n");
		write("\tlinenum = " + stats["linenum"] + "\n");
		write("\tcolumnnum = " + stats["columnnum"] + "\n");
		write("\ttab = " + stats["tab"] + "\n");
		write("\tmaxtab = " + stats["maxtab"] + "\n");
		write("\tcasetype = " + stats["casetype"] + "\n");
	}
	filesinfo[z] = nil;
	pop_scope();
}

/* Simple symbol table functions */
string lookup_value(string var) {
	if (member_map(var, symtable)) {
		return symtable[var]["value"];
	}

	return nil;
}

string lookup_type(string var) {
	if (member_map(var, symtable)) {
	return symtable[var]["type"];
	} 

	return nil;
}

int intable(string var) {
	if (member_map(var, symtable)) {
		symcount[var] = symcount[var] + 1;
		return 1;
	}

	return 0;
}

int insert_symbol(string sym, string type, string val) {
	mapping tmp;

	push_scope();
	debug("insert_symbol: Sym: " + sym + " Type: " +
		type + " Val: " + val);		

	if (intable(sym)) {
		error("Duplicate entry: " + sym);
		pop_scope();
		return 0;
	}

	tmp["value"] = val;
	tmp["type"] = type;
	symcount[sym] = 1;
	symtable[sym] = tmp;

	pop_scope();
	return 1;
}

void dump_table() {
	string val, *keys;
	mapping tmp;
	int x, i;

	write("Symbol Table Dump:\n");
	keys = map_indices(symtable);

	x = sizeof(keys);
	i = 0;

	while (i < x) {
		tmp = symtable[keys[i]];

		val = tmp["value"];
		if (!val) {
			val = "null";
		}

		if (tmp["type"] == "keyword") {
			write("\tSymbol: " + i + ": type: " + tmp["type"] +
				" count: " + symcount[i] + "\n");
		} else {
			write("\tSymbol: " + i + ": type: " + tmp["type"] +
				" value: " + val + "count: " + symcount[i] +
				"\n");
		}
	}
	write("\n\n");
}

int add_stat(string stype, string skey, int svalue) {
	string tmp;

	debug("add_stat: $stype: $skey: $svalue");
	tmp = stype + ":" + skey;
	if (member_map(tmp, stats)) {
		stats[tmp] = stats[tmp] + svalue;
	} else {
		stats[tmp] = svalue;
	}
	return 1;
}

int write_stats(string statfile) {
	int x, max;
	string *keys;

	debug("write_stats");

	/* Note we do not use filehandles in lpc so this is slightly different */

	if (statfile != "") {
		keys = map_indices(stats);
		max = sizeof(keys);
		x = 0;
		while (x < max) {
			if (stats[keys[x]] == "whitespace:\n") {
				write_file(statfile, "whitespace:\\n:" +
					stats[keys[x]] + "\n");
			} else if (stats[keys[x]] == "whitespace:\r") {
				write_file(statfile, "whitespace:\\r:" +
					stats[keys[x]] + "\n");
			} else if (stats[keys[x]] == "whitespace:\t") {
				write_file(statfile, "whitespace:\\t:" +
					stats[keys[x]] + "\n");
			} else {
				write_file(statfile, keys[x] + ":" +
					stats[keys[x]] + "\n");
			}
		}
		return 1;
	}
	return 0;
}

int buf_push(string in) {
	buf = buf + in;
	return 1;
}

string buf_pop() {
	string tmp;
	int start;

	if (match(EOF)) {
		start = strlen(EOF);
		tmp = EOF;
		buf = buf[start..];
	} else {
		tmp = buf[0..0];
		buf = buf[1..];
	}

	return tmp;
}

void buf_clear() {
	buf = "";
}

void buf_show() {
	int x, max;

	if (buf && buf != "") {
		max = strlen(buf);
		x=0;
		while (x < max) {
			write("Buf[" + x + "] = '" + buf[x..x] + "'\n");
			x = x + 1;
		}
	}
}

string _get_char() {
	string char;

	push_scope();
	if (!filename || (filename == "")) {
		write("Ouchie not implementing no infile right now XXX...\n");
		/* char = getc(); */
		char = EOF;
	} else {
		if (!doneread) {
			char = read_file(filename, stats["totalchars"], 1);
			if (!char) { 
				doneread = 1;
				char = EOF;
			} else {
				stats["totalchars"] += 1;
				stats["all_totalchars"] += 1;
			}
		} else {
			char = EOF;
		}
	}

	if (char == "\n") {
		stats["linenum"] += 1;
		stats["all_linenum"] += 1;
		stats["columnnum"] = 0;
	} else {
		stats["columnnum"] += 1;
	}

	debug("_getchar: returning " + char);
	pop_scope();
	return char;
}

int match(string x) {
	int size;
	string tmp;

	push_scope();

 	debug("match:" + x);
	if (option::query_option("debug")) {
		buf_show();
	}

	size = strlen(x);

	while (size > bufsize) {
		error(x + " greater than our buffer size: " + bufsize);
		error("Increasing bufsize by one.");

		bufsize = bufsize + 1;
		tmp = _get_char();
		buf_push(tmp);
	}

	pop_scope();
	if (strstr(buf, x) == 0) {
		return 1;
	}

	return 0;
}

int get_comma() {
	if (match(",")) {
		push_scope();
		debug("get_comma: consumed comma");
		nextchar();
		pop_scope();
		return 1;
	}
	return 0;
}

int get_semi() {
	if (match(";")) {
		push_scope();
		debug("get_semi: consumed ;");
		nextchar();
		pop_scope();
		return 1;
	}
	return 0;
}

int open_output(string tfile) {
	push_scope();
	debug("open_output:");

	/* we don't open a filehandle in lpc so noop here */

	pop_scope();
	return 1;
}

int close_output() {
	push_scope();
	debug("close_output:");

	/* we don't open a filehandle in lpc so noop here */

	pop_scope();
	return 1;
}

int open_compfile(string tfile) {
	push_scope();
	debug("open_compfile:" + tfile);

	stats["linenum"] = 0;
	stats["columnnum"] = 0;
	stats["tab"] = 0;
	stats["maxtab"] = 0;

	filename = tfile;
	/* we don't open a filehandle in lpc so noop here */

	pop_scope();
	return 1;
}

int close_compfile() {
	push_scope();
	debug("close_compfile:");

	/* we don't open a filehandle in lpc so noop here */

	pop_scope();
	return 1;
}

int read_compfile(string tfile) {
	int x;
	string tmp;

	push_scope();
	debug("read_compfile: reading file: " + tfile);

	open_compfile(tfile);
	x = 0;
	while (x < bufsize) {
		tmp = _get_char();
		x = x + 1;
		buf_push(tmp);
	}

	/* This is our hook to our language specific code */
	parser();

	close_compfile();
	pop_scope();

	return 1;
}

int init_backend(string *keyw) {
	int x, c;

	push_scope();
	debug("init_backend: setting defaults");

	symtable = ([]);
	symcount = ([]);
	stats = ([]);

	tokens = ({});
	buf = "";
	bufsize = 9;

	doneread = 0;

	if (keyw) {
		validate_keywords();
		x = sizeof(keyw);
	} else {
		x = 0;
	}

	c = 0;
	while (c < x) {
		insert_symbol(keyw[c], "keyword", keyw[c]);
		c = c + 1;
	}

	stats["totalchars"] = 0;
	stats["all_totalchars"] = 0;
	stats["all_linenum"] = 0;
	/* These get reset in open_file but are needed for input from stdin... */
	stats["linenum"] = 0;
	stats["columnnum"] = 0;
	stats["tab"] = 0;
	stats["maxtab"] = 0;
	stats["filename"] = "<STDIN>";
	stats["project_name"] = "My Project";
	stats["project_description"] = "A simple project, details to follow later.";
	stats["filepath"] = ".";
	stats["filetype"] = "unknown";

	last_tok_type = "";
	last_tok_value = "";

	pop_scope();

	return 1;
}

string get_char() {
	string tmp;

	tmp = _get_char();

	buf_push(tmp);
	tmp = buf_pop();

	if (tmp == "\n") {
		stats["linenum"] = stats["linenum"] + 1;
		stats["all_linenum"] = stats["all_linenum"] + 1;
		stats["columnnum"] = 0;
	} else if (tmp == EOF) {
	} else {
		stats["columnnum"] = stats["columnnum"] + 1;
	}
	stats["totalchars"] = stats["totalchars"] + 1;
	stats["all_totalchars"] = stats["all_totalchars"] + 1;

	return tmp;
}

int load_backend(string file) {
	string err;
	object obj;
	if (file_exists(file)) {
		err = catch(obj = compile_object(file));
		if (!obj) {
			write("Error: " + err + "\n");
			return 0;
		}
		return obj->exec(this_player());
	} else {
		write("Unable to locate " + file + "\n");
		return 0;
	}
}

int add_token(string type, string tvalue, int pos, int line) {
	mapping tmp;

	if ((last_tok_type == type) &&
		!common_follows(last_tok_value, tvalue)) {
		write("WARNING double token type: " + last_tok_value + tvalue +
			", p: " + pos + ", l: " + line + "\n");
	}
	last_tok_type = type;
	last_tok_value = tvalue;
	debug("add_token: " + type + ": " + tvalue + " l:" + line +
		" p:" + pos);
	tmp["type"] = type;
	tmp["value"] = tvalue;
	tmp["line"] = line;
	tmp["pos"] = pos;

	tokens += ({ tmp });
	return 1;
}

string print_whitespace(string in) {
	int x, max;
	string out;

	max = strlen(in);
	out = "";
	for (x = 0; x < max; x++) {
		if (in[x..x] == "\n") {
			out += "\\n";
		} else if (in[x..x] == "\r") {
			out += "\\r";
		} else if (in[x..x] == "\t") {
			out += "\\t";
		} else {
			out += in[x..x];
		}
	}

	return out;
}

/* Need to handle multiple files, and output file as well right now 
 * it just prints to screen. */
int print_tokens(string outputtype) {
	int count, max;
	string str;

	debug("print_tokens");
	if (outputtype == "xml") {
		write("<PROJECT>\n");
		write("\t<PROJECTNAME>" + stats["project_name"] +
			"</PROJECTNAME>\n");
		write("\t<PROJECTDESCRIPTION>" + stats["project_description"] +
			"</PROJECTDESCRIPTION>\n");
		write("\t<FILES>\n");

		write("\t\t<FILE>\n");
		write("\t\t\t<FILENAME>" + stats["filename"] + "</FILENAME>\n");
		write("\t\t\t<PATH>" + stats["filepath"] + "</PATH>\n");
		write("\t\t\t<TYPE>" + stats["filetype"] + "</TYPE>\n");

		count = 0;
		max = sizeof(tokens);
		while (count < max) {
			count = count + 1;
			write("\t\t\t\t<TOKEN>\n");
			write("\t\t\t\t<ID>" + count + "</ID>\n");
			write("\t\t\t\t<LINENUM>" + tokens[count]["line"] +
				"</LINENUM>\n");
			write("\t\t\t\t<COLUMNNUM>" + tokens[count]["pos"] +
				"</COLUMNNUM>\n");
			write("\t\t\t\t<TYPE>" + tokens[count]["type"] +
				"</TYPE>\n");
			if (tokens[count]["type"] == "whitespace") {
				write("\t\t\t\t<VALUE>" +
					print_whitespace(tokens[count]["value"]) +
					"</VALUE>\n");
			} else {
				write("\t\t\t\t<VALUE>" +
					tokens[count]["value"] +
					"</VALUE>\n");
			}
			write("\t\t\t\t</TOKEN>\n\n");
		}

		write("\t\t\t</TOKENS>\n");
		write("\t\t</FILE>\n");
		write("\t</FILES>\n");
		write("</PROJECT>\n");
	} else if (outputtype == "json") {
		write("{\n");
		write("\t\"ProjectName\" : \"" + stats["project_name"] + "\"\n");
		write("\t\"ProjectDescription\" : \"" +
			stats["project_description"] + "\"\n");
		write("\t\"Files\" : [\n");
		write("\t\t\{\n");

		write("\t\t\t\"Filename\" : \"" + stats["filename"] + "\"\n");
		write("\t\t\t\"Path\" : \"" + stats["filepath"] + "\"\n");
		write("\t\t\t\"Type\" : \"" + stats["filetype"] + "\"\n");
		write("\t\t\t\"Tokens\" : [\n");

		count = 0;
		max = sizeof(tokens);
		while (count < max) {
			count = count + 1;
			write("\t\t\t\t\"Token\" : \"" + count + "\",\n");
			write("\t\t\t\t\"Linenum\" : \"" +
				tokens[count]["type"] + "\",\n");
			write("\t\t\t\t\"Columnnum\" : \"" +
				tokens[count]["pos"] + "\",\n");
			write("\t\t\t\t\"Type\" : \"" + tokens[count]["type"] +
				"\",\n");
			if (tokens[count]["type"] == "whitespace") {
				write("\t\t\t\t\"Value\" : \"" +
					print_whitespace(
					tokens[count]["value"]) + "\",\n");
			} else {
				write("\t\t\t\t\"Value\" : \"" +
					tokens[count]["value"] + "\",\n");
			}
			write("\n");
		}

		write("\t\t\t\t},\n");
		write("\t\t\t]\n");
		write("\t\t},\n");
		write("\t]\n");
		write("}\n");

	} else {
		write("\t\"ProjectName\" : \"" + stats["project_name"] + "\"\n");
		write("\t\"ProjectDescription\" : \"" +
			stats["project_description"] + "\"\n");
		write("\t\"Files\" : [\n");

		write("\t\t\"Filename\" : \"" + stats["filename"] + "\"\n");
		write("\t\t\"Path\" : \"" + stats["filepath"] + "\"\n");
		write("\t\t\"Type\" : \"" + stats["filetype"] + "\"\n");
		write("\t\t\"Tokens\" :\n");

		count = 0;
		max = sizeof(tokens);
		while (count < max) {
			count = count + 1;
			write("\t\t\t\"Token\" : \"" + count + "\",\n");
			write("\t\t\t\"Linenum\" : \"" +
				tokens[count]["type"] + "\",\n");
			write("\t\t\t\"Columnnum\" : \"" +
				tokens[count]["pos"] + "\",\n");
			write("\t\t\t\"Type\" : \"" +
				tokens[count]["type"] + "\",\n");
			if (tokens[count]["type"] == "whitespace") {
				write("\t\t\t\"Value\" : \"" +
					print_whitespace(
					tokens[count]["value"]) + "\",\n");
			} else {
				write("\t\t\t\"Value\" : \"" +
					tokens[count]["value"] + "\",\n");
			}
			write("\n");
		}
	}
	return count;
}

int last_token(string param) {
	int max;
	
	max = sizeof(tokens);
	return tokens[max-1][param];
}

