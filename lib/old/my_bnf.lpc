string *keywords;

string filename, parsestring;
int SPACES;
string EOF, buf;
mapping stats;

/* functions defined elsewhere */
int open_output(string filename);
int close_output();
int init_backend(string *keywords);
string set_eof(string chars);
int set_debug(int x);
string get_char();
int nextchar();
int warning(string str);
int debug(string msg);
int error(string str);
int match(string str);
int add_stat(string type, string name, int x);
int add_token(string type, string name, int x, int y);
string get_eof();
void push_scope();
void pop_scope();

int test_rule(string rule, string input) {
	object obj;
	int x;

	filename = "";
	x = open_output("./test_output.o");

	keywords = ({});
	init_backend(keywords);
	set_eof("^F");
	set_debug(1);
	parsestring = input;

	/* prime our reading of the string. */
	get_char();
	nextchar();

	close_output();
	return call_other(obj, rule);
}


int validate_keywords() {
	int warns, i, max, l, x, c;
	string tmp;

	warns = 0;
	i = 0;

	if (!keywords) {
		return 0;
	}

	max = sizeof(keywords);
	while (i < max) {
		l = strlen(keywords[i]);

		x = 0;
		c = 0;
		while (x < max) {
			if (keywords[i] == keywords[x]) {
				c = c + 1;
				if (c > 1) {
					warning("keyword " + keywords[i] +
						" defined multiple times.");
					warns = warns + 1;
				}
			} else if (strlen(keywords[x]) > l) {
				tmp = keywords[x][0..l]; 
				if (tmp == keywords[i]) {
					warning("keywords " + keywords[i] +
						", " + keywords[x] +
						" overlap make sure " +
						keywords[x] +
						" comes first in defines.");
				}
			}
		}

	}
	return warns;
}

int common_follows(string first, string sec) {
	string str, *comm;
	int i, max;

	comm = ({"()", "])", "))", "][", ")[", ");", "((", ")->",
		"),", "];", "]->", "({", "})", "++;", "++)", "--;", "--)",
		"(!", "!(", "..]", "[..", "**,", "**)", "]," });

	str = first + sec;
	i = 0;
	max = sizeof(comm);
	while (i < max) {
		if (comm[i] == str) {
			return 1;
		}
		i = i + 1;
	}
	return 0;
}

int is_keyword(string in) {
	int i, max;

	i = 0;
	max = sizeof(keywords);
	while (i < max) {
		if (keywords[i] == in) {
			return 1;
		}
		i = i + 1;
	}
	return 0;
}

int parser() {
	push_scope();
	debug("parser:");

	while(!match(get_eof())) {
		nextchar();

		/* This is the entrance point to our grammar
			which is defined in our bnf... */
		/* YY_get_syntax(); */
	}
	pop_scope();

	return 1;
}

int YY_start_comment() {
	debug("YY_start_comment");
	if (match("/*") || match("#") || match("//")) {
		return 1;
	}
	return 0;
}

int YY_start_whitespace() {
	debug("YY_start_whitespace");
	if (match("\n") || match("\t") || match(" ") || match("\r")) {
		return 1;
	}
	return 0;
}

int YY_start_string() {
	debug("YY_start_string");
	if (match("\"") || match("'")) {
		return 1;
	}
	return 0;
}

int YY_start_html() {
	debug("YY_start_html");
	if (match("&#")) {
		return 1;
	}
	return 0;
}

int YY_start_hex() {
	debug("YY_start_hex");
	if (match("0x")) {
		return 1;
	}
	return 0;
}

int YY_start_num() {
	string *values;
	int i, max;

	debug("YY_start_num");
	values = ({"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"});
	i = 0;
	max = sizeof(values);

	while (i < max) {
		if (match(values[i])) {
			return 1;
		}
		i = i + 1;
	}
	return 0;
}

int YY_is_int(string str) {
	string *values;
	int i, maxi, x, maxx, done;

	debug("YY_start_int");
	values = ({"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"});

	i = 0;
	maxx = sizeof(values);
	debug("YY_start_int: numstarts: " + maxx);
	maxi = strlen(str);
	while (i < maxi) {
		done = 1;
		x= 0;
		while (x < maxx) {
			if (str[i..i] == values[x]) {
				done = 0;
			}
			x += 1;
		}
		if (done) {
			return 0;
		}
		i += 1;
	}
	return 1;
}

int YY_start_ident() {
	/* A-Z, a-z, _ */
	string *values;
	int i, max;

	debug("YY_start_ident");
	values = ({"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L",
		"M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y",
		"Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l",
		"m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y",
		"z", "_"});

	i = 0;
	max = sizeof(values);
	debug("YY_start_ident: numstarts: " + max);

	while (i < max) {
		if (match(values[i])) {
			return 1;
		}
		i = i + 1;
	}
	return 0;
}

int YY_start_op() {
	string *values;
	int i, max;

	debug("YY_start_op");
	values = ({"|", "-", "!", "#", "\$", "\%", "&", "(", ")", "*",
		"+", ",", "-", ".", "/", ":", ";", "<", "=", ">", "?", "\@",
		"[", "]", "^", "`", "{", "|", "}", "~", "\\"});

	i = 0;
	max = sizeof(values);
	debug("YY_start_op: numstarts: " + max);

	while (i < max) {
		if ( match(values[i])) {
			return 1;
		}
		i = i + 1;
	}
	return 0;
}

int YY_valid_hex() {
	string *values;
	int i, max;

	debug("YY_start_hex");
	values = ({"0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
		"A", "B", "C", "D", "E", "F", "a", "b", "c", "d", "e", "f"});

	i = 0;
	max = sizeof(values);
	debug("YY_start_hex: numvalues: " + max);

	while (i < max) {
		if (match(values[i])) {
			return 1;
		}
		i = i + 1;
	}
	return 0;
}

int YY_get_comment() {
	string com, tmp, lastchar;
	int p, l;

	push_scope();
	debug("YY_get_comment");

	if (!YY_start_comment()) {
		return 0;
	}

	if (member_map("clumnnum", stats)) {
		p = stats["cloumnnum"];
	} else {
		p = 0;
	}
	if (member_map("linenum", stats)) {
		l = stats["linenum"];
	} else {
		l = 0;
	}
	com = "";

	if (match("//") || match("#")) {
		while (!match("\n") && !match(get_eof())) {
			tmp = get_char();
			com += tmp;
		}

		debug("single comment = '" + com + "'");
		add_stat("comment", "singleline", 1);
		add_token("comment", com, p, l);

		pop_scope();
		return 1;
	} else { /* get multiline comment */
		while (!match("*/") && !match(get_eof())) {
			tmp = get_char();
			com += tmp;
		}

		if (!match(get_eof())) { /* eat the end of comment */
			tmp = get_char();
			com += tmp;
			tmp = get_char();
			com += tmp;
		}
		debug("double comment = '" + com + "'");
		add_stat("comment", "multiline", 1);
		add_token("comment", com, p, l);

		pop_scope();
		return 1;
	}
	pop_scope();
	return 0;
}

int YY_get_whitespace() {
	string tmp, word;
	int p, l;

	push_scope();
	debug("YY_get_whitespace:");

	if (!YY_start_whitespace()) {
		pop_scope();
		return 0;
	}

	if (member_map("clumnnum", stats)) {
		p = stats["cloumnnum"];
	} else {
		p = 0;
	}
	if (member_map("linenum", stats)) {
		l = stats["linenum"];
	} else {
		l = 0;
	}
	tmp = get_char();
	word = tmp;

	if (tmp == " ") {
		add_stat("whitespace", "SPACE", 1);
	} else {
		add_stat("whitespace", tmp, 1);
	}

	while(match(" ") || match("\t") || match("\n") || match("\r")) {
		tmp = get_char();
		word += tmp;

		if (tmp == " ") {
			add_stat("whitespace", "SPACE", 1);
		} else {
			add_stat("whitespace", tmp, 1);
		}
	}
	add_token("whitespace", word, p, l);
	debug("YY_get_whitespace: added '" + tmp + "' length:" + strlen(tmp) +
		"\n");
	pop_scope();

	return 1;
}

int YY_get_string() {
	string tmp, word, lastchar, type;
	int p, l;

	type = get_char();
	push_scope();
	debug("YY_get_string:" + type);

	if (!YY_start_string()) {
		pop_scope();
		return 0;
	}

	if (member_map("clumnnum", stats)) {
		p = stats["cloumnnum"];
	} else {
		p = 0;
	}
	if (member_map("linenum", stats)) {
		l = stats["linenum"];
	} else {
		l = 0;
	}

	while(!match(get_eof()) && !match(type)) {
		tmp = get_char();
		if (tmp == "\\") { /* we have an escape read the
					next char as well and treat is as
					one symbol... */
			tmp += get_char();
		}
		word += tmp;
		lastchar = tmp;
	}
	debug("YY_get_string: string = " + word);
	add_stat("string", type, 1);
	add_token("string", word, p, l);
	/* eat the end of string token */
	tmp = get_char();

	pop_scope();

	return 1;
}

int YY_get_html() {
	string tmp, word;
	int p, l;

	push_scope();
	debug("YY_get_html:");

	if (!YY_start_html()) {
		pop_scope();
		return 0;
	}

	if (member_map("clumnnum", stats)) {
		p = stats["cloumnnum"];
	} else {
		p = 0;
	}
	if (member_map("linenum", stats)) {
		l = stats["linenum"];
	} else {
		l = 0;
	}

	word = "";
	while(!match(get_eof()) && (!match(";"))) {
		tmp = get_char();
		word += tmp;
	}

	if (YY_is_int(word)) {
		debug("YY_get_html found: " + word);
		add_stat("literal", "html", 1);
		add_token("html", word, p, l);
		pop_scope();
		return 1;
	}
	error("YY_get_html: " + word + ", expected: &#DDDD;");
	pop_scope();
	return 0;
}

int YY_get_hex() {
	string word;
	int p, l;

	push_scope();
	debug("YY_get_hex:");

	if (!YY_start_hex()) {
		pop_scope();
		return 0;
	}

	if (member_map("clumnnum", stats)) {
		p = stats["cloumnnum"];
	} else {
		p = 0;
	}
	if (member_map("linenum", stats)) {
		l = stats["linenum"];
	} else {
		l = 0;
	}

	word = get_char() + get_char(); /* grab the 0x */
	if (YY_valid_hex()) {
		word += get_char();
	} else {
		return 0;
	}

	if (YY_valid_hex()) {
		word += get_char();
	} else {
		return 0;
	}

	debug("YY_get_hex: " + word);
	add_stat("literal", "hex", 1);
	add_token("hex", word, p, l);
	pop_scope();
	return 1;
}

int YY_get_num() {
	string word;
	int p, l;

	push_scope();
	debug("YY_get_num:");

	if (!YY_start_num()) {
		pop_scope();
		return 0;
	}

	if (member_map("clumnnum", stats)) {
		p = stats["cloumnnum"];
	} else {
		p = 0;
	}
	if (member_map("linenum", stats)) {
		l = stats["linenum"];
	} else {
		l = 0;
	}

	word = get_char();
	while (YY_start_num()) {
		word += get_char();
	}
	if (match("..")) {
		debug("YY_get_num " + word);
		add_stat("num", "int", 1);
		add_token("int", word, p, l);
		SPACES = SPACES - 1;
		return 1;
	} else if (match(".")) {
		word += get_char();
		while(YY_start_num()) {
			word += get_char();
		}
		debug("YY_get_num " + word);
		add_stat("num", "float", 1);
		add_token("float", word, p, l);
		pop_scope();
		return 1;
	}
	debug("YY_get num " + word);
	add_stat("num", "int", 1);
	add_token("int", word, p, l);
	pop_scope();
	return 1;
}

int YY_get_ident() {
	string word;
	int p, l;

	push_scope();
	debug("YY_get_ident: ");

	if (!YY_start_ident()) {
		pop_scope();
		return 0;
	}

	if (member_map("clumnnum", stats)) {
		p = stats["cloumnnum"];
	} else {
		p = 0;
	}
	if (member_map("linenum", stats)) {
		l = stats["linenum"];
	} else {
		l = 0;
	}

	word = get_char();
	debug("YY_get_ident: start = '" + word + "'");
	while(YY_start_num() || YY_start_ident()) {
		word += get_char();
	}

	debug("YY_get_ident: '" + word + "'");
	if (is_keyword(word)) {
		add_stat("keyword", word, 1);
	} else {
		if (option::query_option("names")) {
			add_stat("ident", word, 1);
		} else {
			add_stat("ident", "ident", 1);
		}
	}
	add_token("ident", word, p, l);
	pop_scope();
	return 1;
}

int YY_get_op() {
	string op, *multiop;
	int p, l, doneop, y, maxy, x, maxx;

	/* make sure larger ops defined first */
	multiop = ({">>=", "<<=",
		"!=", "==", "||", ">=", "<=", "++", "--", "&&", ">>", "<<",
		"+=", "-=", "*=", "/=", "%=", "&=", "|=", "^=", "?:", "->",
		"::", "<-", "!!", "=~", "=~", ".."});

	push_scope();
	debug("YY_get_op:");

	if (!YY_start_op()) {
		pop_scope();
		return 0;
	}

	if (member_map("clumnnum", stats)) {
		p = stats["cloumnnum"];
	} else {
		p = 0;
	}
	if (member_map("linenum", stats)) {
		l = stats["linenum"];
	} else {
		l = 0;
	}

	y = 0;
	maxy = sizeof(multiop);
	while (y < maxy) {
		if (match(multiop[y])) {
			x = 0;
			op = "";
			maxx = strlen(multiop[y]);
			while (x < maxx) {
				op += get_char();
				x += 1;
				doneop = 1;
			}
		}
		y += 1;
	}

	if (!doneop) {
		op = get_char();
	}
	debug("YY_get_op: " + op);
	add_token("op", op, p, l);
	add_stat("opp", op, 1);
	pop_scope();
	return 1;
}

/*
void YY_get_syntax() {
	push_scope();
	debug("YY_get_syntax: Buf: " . buf[0]);
	while(token == "ident") {
		YY_get_rule();
	}
	pop_scope();
}
*/

/* This defines the major things that will show up in our code and
 * is a function to get the next thing need to make sure there are no
 * overlaps.... (if ident allows _wah _ can't be an operator...) */
int nextchar() {
	push_scope();
	debug("nextchar:");

	if (match(EOF)) {
	} else if (YY_start_comment()) {
		YY_get_comment();
	} else if (YY_start_whitespace()) {
		YY_get_whitespace();
	} else if (YY_start_ident()) {
		YY_get_ident();
	} else if (YY_start_string()) {
		YY_get_string();
	} else if (YY_start_html()) {
		YY_get_html();
	} else if (YY_start_hex()) {
		YY_get_hex();
	} else if (YY_start_num()) {
		YY_get_num();
	} else if (YY_start_op()) {
		YY_get_op();
	} else {
		error("nextchar: invalid input: " + buf[0]);
		return 0;
	}
	pop_scope();

	return 1;
}
